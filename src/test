let R = require("ramda")
let dbFile = "./todo.json"
let archiveDBFile = "./archive.json"
let FS = require("fs-extra")

//commands

let commands = {}

let writeFileX = R.curry((dbFile, todo) => {
  let str = typeof todo == "string" ? todo : JSON.stringify(todo, null, 2)
  FS.outputFileSync(dbFile, str, "utf-8")
})

let writeFileArchive = R.curry((archiveDBFile, todo) => {
  let str = typeof todo == "string" ? todo : JSON.stringify(todo, null, 2)
  FS.outputFileSync(archiveDBFile, str, "utf-8")
})

let rankingArchive = (todo) => {
return Number(todo.status != "archived") // archive == 1, * == 0
}

let ranking = (todo) => {
return Number(todo.status != "active") // archive == 1, * == 0
}

let load = () => require(dbFile)
let save = (todos) => {writeFileX(dbFile, todos); logAll(todos) }
let loadArchive = () => require(archiveDBFile)
let archiveSave = (todos) => {writeFileArchive(archiveDBFile, todos); logArchive(todos) }

let forEachI = R.addIndex(R.forEach)

let logLine = (todo, i) => {
  console.log(
    todo.done == false ? `[ ] ${i + 1}. ${todo.text}` :
    todo.done == true  ? `[x] ${i + 1}. ${todo.text}` :
                              `` // ignore archived todos
  )
}
let logAll = forEachI(logLine)

let logLineArchive = (todo, i) => {
  console.log(
    todo.done == true ? `[#] ${i + 1}. ${todo.text}` : ``
  )
}
let logArchive = forEachI(logLineArchive)

commands.init = function () {
  let todos = []
  writeFileX(dbFile, todos)
  let archive = []
  writeFileX(archiveDBFile, todos)
  console.log("Ready to work!")
}

commands.list = function () {
  let todos = load()
  logAll(todos)
  }

commands.add = function (text) {
  let todos = load()
  let addTodos = R.append({text, "done": false}, todos)
  save(addTodos)
}

commands.delete = function (index) {
  let todos = load()
  let deleteTodos = R.remove(index, 1, todos)
  save(deleteTodos)
}

commands.done = function (index) {
  let todos = load()
  let doneTodos = R.update(index, R.assoc("done", true, todos[index]), todos)
  save(doneTodos)
}

/*commands.archive = function () {
  let activeTodos = load()
  let archiveTodos = loadArchive()
  let doneTodos = R.map(todo => todo.status == "done" ? R.assoc("status", "archived", todo) : todo, activeTodos)
  //для актива
  let sortActiveTodos = R.sortBy(ranking, doneTodos)
  let takeActive = R.takeWhile(todo => todo.status == "active", sortActiveTodos)
  //для архива
  let sortArchiveTodos = R.sortBy(rankingArchive, doneTodos)
  let takeArchive = R.unnest(R.append(R.takeWhile(todo => todo.status == "archived", sortArchiveTodos), archiveTodos))
  /*writeFileX(dbFile, sortTodos)
  forEachI(
    (todo, index) => console.log(todo.status != "active" ? "[#]" : "[]", index + 1 + ".", todo.text),
    sortTodos
  )
  save(takeActive)
  archiveSave(takeArchive)
}*/

commands.archive = function () {
  let activeTodos = load() // загружаем текущие
  let archiveTodos = loadArchive() // загружаем архивные
  let activeTodos2 = R.reject(R.prop("done"), activeTodos) // выбрасываем сделанные из текущих
  let archiveTodos2 = R.concat(R.filter(R.prop("done"), activeTodos), archiveTodos) // добавляем сделанные к архивным
  save(activeTodos2) // сохраняем новую версию текущих
  archiveSave(archiveTodos2) // сохраняем новую версию архива
}

//command manager

let operation = process.argv[2]

switch (operation) {
  case "init":
    return commands.init()
  case "add":
    let text = process.argv[3]
    return commands.add(text)
  case "list":
    return commands.list()
  case "delete":
    let deleteIndex = Number(process.argv[3]) - 1
    return commands.delete(deleteIndex)
  case "done":
    let doneIndex = Number(process.argv[3]) - 1
    return commands.done(doneIndex)
  case "archive":
    return commands.archive()
  default:
    throw Error(`unsupported operation ${operation}`)
}
